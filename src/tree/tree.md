#完成删除节点的操作

##规定：
1.如果删除的结点是叶子节点，则删除该节点；
2.如果删除的结点是非叶子节点，则删除该子树
##思路：
首先先考虑是不是空树，如果树是空树root，只有一个root结点，则等价将二叉树置空

1.因为我们的二叉树是单向的，所以我们要判断当前节点的子节点是否是需要删除的
结点，而不能去判断当前节点是不是要删除的结点；

2.如果当前节点的左子节点不为空，并且左子节点是要删除节点，就将this.left=null,
并且就返回（结束递归删除）；

3.如果当前节点的右子节点不为空，并且右子节点就是要删除结点，就将this.right=null,
并且就返回（结束递归删除）；

4.如果2和3都没有删除节点，那么我们就需要向左子树进行递归删除；

5.如果4页没有删除，则应当向右子树递归删除

#顺序存储二叉树
##顺序存储二叉树的特点：

1.第n个结点的左子节点是2*n+1;
2.第n个结点的右子节点是2*n+2;
3.第n个元素的父节点为（n-1）/2;
4.n从0开始；

#堆排序
1.将无序序列构建成一个堆，根据升序降序选择大根堆或者小根堆

2.将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端

3.重新调整结构使其满足堆定义，然后继续交换堆顶元素和末尾元素，反复执行调整

#赫夫曼树
1.从小到大进行排序，将每一个数据，每一个数据都是一个结点，每一个节点都可以看成是一颗最简单的二叉树

2.取出结点权值最小的两颗二叉树

3.组成一个新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和

4.在将这新的二叉树，以根节点权值大小再次排序，不断重复1,2,3,4直到数列中，所有数据都被处理，就得到一颗
赫夫曼树

#数据压缩
功能：根据赫夫曼编码压缩数据的原理，需要创建“i like like like java do you like a java”对应的赫夫曼树

思路：
1.Node{data(存放数据)，weight(权值)，left和right}
2.得到“i like like like java do you like a java”对应的byte[]数组
3.编写一个方法，将准备的赫夫曼树的Node结点放到List,形式[Node[data=97,weight=5]]
4.可以通过List创建对应的赫夫曼树